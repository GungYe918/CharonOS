#pragma once

#include <stdint.h>

#define EI_NIDENT 16                    // ELF헤더의 크기를 나타내는 상수이다.

typedef uintptr_t Elf64_Addr;           // 64비트 주소를 나타내는 데이터 타입이다. 프로그램이 로드될 때의 가상 메모리 주소를 나타내는 데 사용된다.
typedef uint64_t  Elf64_Off;            // 64비트 오프셋(파일 내의 특정 위치를 나탸내는 값)을 나타내는 테이터 타입이다. 파일 내에서의 위치를 나타내는 데 사용된다.
typedef uint16_t  Elf64_Half;           // 16비트 부호 없는 정수를 나타내는 데이터 타입이다. ELF파일의 다양한 필드에서 사용된다. 
typedef uint32_t  Elf64_Word;           // 32비트 부호 없는 정수를 나타내는 데이터 타입이다. ELF파일의 다양한 필드에서 사용된다.
typedef int32_t   Elf64_Sword;          // 32비트 부호 있는 정수를 나타내는 데이터 타입이다. ELF파일의 다양한 필드에서 사용된다..
typedef uint64_t  Elf64_Xword;          // 64비트 부호 없는 정수를 나타내는 데이터 타입이다. ELF파일의 다양한 필드에서 사용된다.
typedef int64_t   Elf64_Sxword;         // 64비트 부호 있는 정수를 나태내는 데이터 타입이다. ELF파일의 다양한 필드에서 사용된다.


/**
 * 필드란? 일반적으로 섹션 헤더, 프로그램 헤더 등의 구조 내의 각 항목을 나타낸다.
*/


typedef struct {

  Elf64_Word  p_type;                   // PHDR, LOAD등 세그먼트 종류
  Elf64_Word  p_flags;                  // Flag값
  Elf64_Off   p_offset;                 // Offest값
  Elf64_Addr  p_vaddr;                  // 가상 Addr
  Elf64_Addr  p_paddr;
  Elf64_Xword p_filesize;               // 파일 사이즈
  Elf64_Xword p_memsize;                // 메모리 사이즈
  Elf64_Xword p_align;

} Elf64_Phdr;

/**
 * 아래의 프로그램 헤더 테이블에 대한 예시에 자세히 설명되어 있다.
*/


typedef struct {

  unsigned char e_ident[EI_NIDENT];     // ELF헤더의 식별자, ELF의 버전, 형식 등을 식별, 16바이트
  Elf64_Half    e_type;                 // ELF파일의 형식을 의미 ex -> 실행 파일? 공유 라이브러리? .o파일?
  Elf64_Half    e_machine;              // ELF파일이 실행될 목표 시스템의 아키텍처를 의미 ex -> x86? ARM?
  Elf64_Word    e_version;              // ELF파일의 형식 버전을 의미
  Elf64_Addr    e_entry;                // 프로그램의 진입점의 가상 주소를 의미, 프로그램의 시작지점을 나타낸다.
  Elf64_Off     e_phoff;                // 프로그램 헤더 테이블(Program Header Table)의 파일 오프셋
  Elf64_Off     e_shoff;                // 섹션 헤더 테이블(Section Header Table)의 파일 오프셋
  Elf64_Word    e_flags;                // ELF파일의 특정 플래그를 의미한다.
  Elf64_Half    e_ehsize;               // ELF헤더의 크기를 의미한다.
  Elf64_Half    e_phentsize;            // 프로그램 헤더 엔트리의 크기를 의미한다.       
  Elf64_Half    e_phnum;                // 프로그램 헤더 테이블의 엔트리 수를 의미한다.      **프로그램 헤더 엔트리 수란? ELF파일에 포함된 프로그램 세그먼트의 수를 의미한다.
  Elf64_Half    e_shentsize;            // 섹션 헤더 엔트리의 크기를 의미한다.
  Elf64_Half    e_shnum;                // 섹션 헤더 테이블의 엔트리 수를 의미한다.         **섹션 헤더 테이블의 엔트리 수란? ELF파일에 포함된 섹션의 개수를 의미한다.
  Elf64_Half    e_shstrndx;             // 섹션 이름 문자열 테이블의 섹션 헤더 인덱스를 의미한다.

} Elf64_Ehdr;


#define PT_NULL    0                    // 빈 1)세그먼트, 일반적으로 사용되지 않으며 표시 용도로만 사용
#define PT_LOAD    1                    // 프로그램를 메모리로 로드하는 데 사용되는 세그먼트. 프로그램의 코드나 데이터 포함 가능
#define PT_DYNAMIC 2                    // 동적 링크 정보를 포함하는 세그먼트. 공유 라이브러리와의 동적 링크에 필요한 정보를 제공한다.
#define PT_INTERP  3                    // 인터프리터의 경로를 지정하는 세그먼트. 실행 중에 사용되는 2)인터프리터의 경로를 지정한다.
#define PT_NOTE    4                    // 추가적인 정보를 포함하는 세그먼트이다. 주로 디버그 정보나 프로그램에 대한 추가적인 메타데이터를 포함한다.
#define PT_SHLIB   5                    // 예악된 값으로 이 세그먼트 유형은 현재 사용되지 않는다.
#define PT_PHDR    6                    // 3)프로그램 헤더 테이블의 위치와 크기를 지정하는 세그먼트이다.
#define PT_TLS     7                    // 4)Thread-Local Storage(TLS)를 위한 초기화 데이터를 포함하는 세그먼트이다.

/**
 * 1) 세그먼트
 *      프로그램의 로딩과 실행에 필요한 데이터를 묶어놓은 논리적인 단위를 나타낸다.
 * 
 * 2) 인터프리터
 *      프로그램이 실행될 시 사용되는 실행 환경을 제공하는 프로그램을 말한다.
 * 
 * 3) 프로그램 헤더 테이블
 *      프로그램이 로드될 때 필요한 정보를 포함하는 테이블을 말한다.
 *      EX:
 *      p_type: 세그먼트의 유형을 나타내는 필드로 PT_LOAD, PT_DYNAMIC, PT_INTERP 등과 같은 값을 가진다.
 *      p_offset: ELF파일 내에서 세그먼트의 시작 위치를 나타내는 필드이다.
 *      p_vaddr: 세그먼트가 메모리에 로드될 때의 가상 메모리 주사를 나타내는 필드이다.
 *      p_filesz: 세그먼트의 크기를 파일 상에서 나타내는 필드이다.
 *      p_memsz: 세그먼트가 메모리에 로드될 때의 크기를 나타내는 필드이다.
 *      p_flags: 세그먼트의 속성을 지정하는 필드로, 읽기, 쓰기 등의 속성을 지정한다.
 *      p_align: 세그먼트의 정렬을 나타내는 필드로, 로드될 때의 정렬 요구 사항을 나타낸다.
 * 
 *      위의 Elf64_Phdr 구조체에 정의되어 있다.
 * 
 * 4) Thread-Local Storage(TLS)
 *      멀티스레드 환경에서 각 스레드가 독립적으로 사용하는 데이터를 저장하는 메모리 영역을 말한다.
 *      TLS는 멀티스레드 환경에서 각 스레드가 고유한 데이터를 유지하고 관리하는 데 사용된다.
*/


typedef struct {

  Elf64_Sxword d_tag;                   // 1)동적 링킹 태그를 나타내는 필드이다. 이 필드는 동적 링킹이 어떤 종류의 정보를 포함하고 있는지를 식별하는 데 사용된다.
  union {                               // 이 필드는 동적 링킹의 값을 나타내는데 사용된다. d_val또는 d_ptr중 하나를 사용하여 동적 링킹의 값을 표현한다.
    Elf64_Xword d_val;                  // 정수 값으로 동적 링킹의 데이터를 저장한다.
    Elf64_Addr d_ptr;                   // 메모리 주소로 동적 링킹의 데이터를 저장한다.
  } d_un;

} Elf64_Dyn;

/**
 * 1) 동적 링킹 
 *      실행 파일이 로드될 때 라이브러리나 모듈을 동적으로 로드하고 연결하는 프로세스를 의미한다.
 *      이를 통해 프로그램은 실행 중에 필요한 라이브로리를 로드하여 사용할 수 있다.
 * 
 * PLUS: 동적 링킹 섹션
 *      ELF파일은 동적 링킹에 대한 정보를 제공하는 섹션들을 포함하고 있다. 이러한 섹션들은 일반적으로 "동적 링킹 섹션"으로 불린다.
 *      동적 링킹 섹션은 주로 다음과 같은 정보를 포함한다.
 *        1) 동적 링킹 테이블(Dynamic Linking Table):
 *            이 섹션에는 동적 링킹에 필요한 정보가 포함된다. 주로 동적 라이브러리의 이름, 함소 호출과 재배치 정보 등이 포함된다.
 *        2) 재배치 섹션(Relocation Section):
 *            재배치 섹션은 프로그램이 메모리에 로드된 때 주소 공간의 변화에 대응하여 주소나 심볼을 조정하는 데 사용된다.
 *        3) 심볼 테이블 섹션(Symbol Table Section):
 *            동적 링크 시 필요한 심볼들과 그에 대한 정보를 포함한다. 동적 링크 로더는 이러한 심볼 테이블을 사용하여 외부 심볼의 위치를 찾거나 함수 호출을 해결한다.
 * 
 * 2) 태그
 *      해당 섹션이 어떤 종류의 정보를 포함하고 있는지를 식별하는 데 사용된다.
 *      태그는 Elf64_Dyn 구조체의 Elf64_Sxword d_tag 필드로 표현된다. 태그 값은 정수 형태로 저장되며 여러 태그가 이미 정의되어 있다.
 *      EX:
 *      - DT_NULL: 동적 링킹 섹션의 끝을 나타낸다.
 *      - DT_NEEDED: 해당 ELF파일이 의존하고 있는 동적 라이브러리의 이름을 나타낸다.
 *      - DT_STRTAB: 동적 문자열 테이블의 주소를 나타낸다.
 *      - DT_REL or DT_RELA: 재배치 정보가 포함된 섹션의 주소를 나타낸다.
 *      More info -> https://man7.org/linux/man-pages/man5/elf.5.html
 *  
*/      


#define DT_NULL    0                    // 동적 섹션의 끝을 나타낸다.
#define DT_RELA    7                    // 재배치 정보가 포함된 섹션의 주소를 나태난다.
#define DT_RELASZ  8                    // 재배치 섹션의 크기를 나타낸다.
#define DT_RELAENT 9                    // 각 재배치 항목의 크기를 나타내며, 재배치 섹션의 각 항목이 차지하는 바이트 수를 지정한다.


typedef struct {                        // 동적 링킹 섹션에 포함된 재배치 정보를 표현하는 구조체이다.

  Elf64_Addr r_offset;                  // 재배치가 적용될 위치를 나타낸다. 이 값은 프로그램이 메모리에 로드될 때 실제로 수정되어야 하는 메모리 주소를 가리킨다.
  Elf64_Xword r_info;                   // 재배치 정보를 포함하는 필드이다. 이 필드는 재배치된 심볼에 대한 정보를 담고 있다. 일반적으로 상위 비트에 재배치 된 심볼을, 하위 비트에 재배치된 심볼의 유형을 나타낸다.
  Elf64_Sxword r_addend;                // 추가적인 값을 저장하는 필드이다. 일부 재배치 작업은 이러한 추가적인 오프셋을 필요로 한다.

} Elf64_Rela;


#define ELF64_R_SYM(i)    ((i)>>32)
#define ELF64_R_TYPE(i)   ((i)&0xffffffffL)
#define ELF64_R_INFO(s,t) (((s)<<32)+((t)&0xffffffffL))

#define R_X86_64_RELATIVE 8                                   

/**
 * I) ELF64_R_SYM(i):
 *      이 매크로는 재배치 정보 'i'에서 심볼을 추출한다. 재배치 정보는 일반적으로 64비트 정수이며
 *      상위 32비트에 심볼을 나태내는 인덱스가 정의되어 있다. 이 매크로는 재비채 정보의 상위 32비트를 오른족 시프트 연산을 통해 추출하여 심볼을 반환한다.
 * 
 * II) ELF64_R_TYPE(i):
 *      이 매크로는 재배치 정보 'i'에서 재배치 유형을 추출한다. 이 매크로는 재배치 정보의 하위 32비트를 
 *      1)마스킹 연산을 통해 추출하여 재배치 유형을 반환한다.
 * 
 * III) ELF64_R_INFO(s, t):
 *      이 매크로는 심볼 's'와 재배치 유형 't'를 조합하여 재배치 정보를 생성한다. 심볼과 재배치 유형은 각각 32비트로 제공되며, 
 *      이 매크로는 심볼을 상위 32비트로, 재배치 유형을 하위 32비트로 조합하여 재배치 정보를 생성한다.
 * 
 * IV) R_X86_64_RELATIVE(8):
 *      이 상수는 x86_64아키텍처에서 사용되는 특정 재배치 유형을 나타낸다. 이 재배치 유형은 RELATIVE라고 불리며, 상대적인 주소를 처리하는 데 사용된다.
 *      RELATIVE재배치는 프로그램이 실행될 때 해당 주소가 프로그램의 기본 주소로부터의 상대적인 오프셋으로 해석된다.
*/


/**
 * 1) 마스킹 연산:
 *      마스킹 연산은 비트 단위로 데이터를 조작하는 연산으로, 주어진 비트 패턴을 사용하여 특정 위치의 비트를 추출하거나 제거하는 데 사용한다.
 * 
 *      EX:
 *      1. 비트 추출:
 *          특정 위치의 비트를 추출하는 경우, 마스크를 사용하여 해당 비트 위치의 비트만 남기가 나머지 바트를 모두 0으로 만든다. 
 *          이를 위해 AND연산을 사용하여 마스크와 원래 데이터를 연산한다.
 *      2. 비트 제거:
 *          특정 위치의 비트를 제거하는경우 마스크를 사용하여 해당 비트 위치의 비트를 0으로 만든다.
 *          이러한 연산을 위해 AND연산을 사용해서 마스크의 해당 비트 위치에 있는 비트만 유지하고 나머지 비트를 0으로 만든다.
*/